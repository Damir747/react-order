1. Родной useEffect срабатывает асинхронно

Когда срабатывает:
— React сначала рендерит и коммитит изменения в DOM.
— Потом асинхронно, уже после отрисовки, запускает функции из useEffect.

Типичные кейсы (из доки):
— подключение к чату, WebSocket’у;
— глобальные события браузера;
— запуск анимаций;
— управление модальными окнами;
— отслеживание видимости элементов и т. д.

Важный момент: useEffect никак не вызывает рендер! Иногда новички на собеседовании говорят, "при пустом массиве зависимостей рендер произойдет после первой отрисовки", что не верно, useEffect срабатывает после рендера, но рендер не вызывает.

2. useLayoutEffect выполнится синхронно после коммита DOM и до отрисовки экрана

Что говорит дока:
— useLayoutEffect — версия useEffect, которая срабатывает до того, как браузер перерисует экран. 

То есть порядок такой:
— React рендерит и изменяет DOM.
— Срабатывают useLayoutEffect.
— Браузер рисует кадр.

После этого уже выполняются обычные useEffect. 

Зачем так рано?
— надо измерить layout (getBoundingClientRect, размеры/позицию элементов),
— и/или сразу отреагировать на измерение, чтобы пользователь не увидел “дёрганья” интерфейса.

3. Также в React есть официальный хук useInsertionEffect: выполняется синхронно (блокирует paint) и выполняется раньше useLayoutEffect

Предназначен в первую очередь для авторов CSS-in-JS библиотек для вставки стилей.